= jtwfg Java library
Peti Koch
:imagesdir: ./docs
:project-name: jtwfg
:github-branch: master
:github-user: Petikoch
:bintray-user: petikoch

image:https://travis-ci.org/{github-user}/{project-name}.svg?branch={github-branch}["Build Status", link="https://travis-ci.org/{github-user}/{project-name}"]
image:http://img.shields.io/badge/license-ASF2-blue.svg["Apache License 2", link="http://www.apache.org/licenses/LICENSE-2.0.txt"]
image:http://img.shields.io/badge/download-latest-bb00bb.svg[link="https://bintray.com/{bintray-user}/maven/{project-name}/_latestVersion"]

== Introduction

jtwfg implements a *task wait for graph* model with a deadlock detection algorithm.

The graph consists of *tasks* and synchronous *waits-for edges*. As soon as a circular dependency exists, the involved tasks are _deadlocked_.

jtwfg is a small, standalone java library. The typical use case for someone is having some kind of own "execution engine" implementation
(local, distributed, grid...) with some kind of tasks in it with optionally dependencies between the tasks.
Someone wants to be able to detect deadlocks at runtime in his/her engine automatically.

At the moment, only simple, synchronous dependencies are supported by jtwfg.

=== Example 1

In this first example you see two tasks, each waiting for the other.

image::two_tasks_deadlocked.png[]

Since they are both waiting synchronously for each other *forever*, they are _deadlocked_.

jtwfg can analyze such graphs and find the deadlock(s).

=== Example 2

The situation in the second example is a bit more interesting.

image::many_tasks_deadlocked.png[]

Here, we have a circle consisting of "Task 1", "Task 2" and "Task 3". Since they are all waiting synchronously for each other *forever*, they are _deadlocked_.
"Task 4" is also _deadlocked_, although it is not in the circle. It's is waiting for a _deadlocked_ task.
Same for "Task 6" and "Task 7", also _deadlocked_.

"Task 5" is fine.

jtwfg can analyze such graphs and find the deadlock(s).

=== Motivation for jtwg

Since I didn't found a "small" and "standalone" library for custom engine deadlock detection on the JVM, I wrote my own. Party!
If you know a solution I didn't find, thanks for pointing to it in advance.

=== More about the deadlock detection topic in general

For more details about deadlock detection algorithms see e.g. http://se.inf.ethz.ch/old/projects/daniel_moser/project_report_deadlock_detection.pdf[Daniel Moser's semester project].

== Usage of jtwfg

=== Basic scenario

==== Step 1

At some point in time you wonder about having a deadlock in your custom engine domain model.
You transform your domain model into the (simple) jtwfg-model using a graph builder object:

[source,java]
----
GraphBuilder builder = new GraphBuilder();
builder.addTaskWaitsFor("task 1", "task 2");
builder.addTaskWaitsFor("task 2", "task 1");
builder.addTask("task 3");
builder.addTask("task 4");
Graph graph = builder.build();
----

==== Step 2

As soon as you have a jtwfg-Graph instance, you can use the jtwfg deadlock detector to find deadlocks.

[source,java]
----
DeadlockDetector deadlockDetector = new DeadlockDetector();
DeadlockAnalysisResult analyzisResult = deadlockDetector.analyze(graph);
if(analyzisResult.hasDeadlock()){
   // do something in your domain like throwing an exception or killing a task or ...
   //
   // System.out.println(analyzisResult)
}
----

=== Scenario 2: "Update the jtwfg model" as you update your domain model and check for deadlocks on the fly

Probably you want to keep the jtwfg model "in sync" with your domain model and check for deadlocks on the fly
as soon as you update your model. Probably you use various threads to update your domain model and the jtwfg model.

That's fine.

See link:src/test/groovy/ch/petikoch/libs/jtwfg/Documentation.groovy[executable documentation in src/test/groovy] for
this and more examples.

=== Thread-safety of jtwfg

For simplicity and comfort GraphBuilder and DeadlockDetector are threadsafe. If you would like to use it
single-threaded and have performance issues, let me know.

== Requirements

To use this library you need

* Java 7 or later
* no other libs

== Installation

=== Usage in Gradle, Maven, ...

==== Gradle based build

Add the following dependency in your gradle build file:

[source,groovy]
----
repositories {
   jcenter() // Bintray's JCenter repository
}

dependencies {
    compile 'ch.petikoch.libs.jtwfg:jtwfg:1.0.0' // or whatever explicit version

    // or "latest":
    //compile 'ch.petikoch.libs.jtwfg:jtwfg:+'
}
----

==== Maven based build

Add jtwfg as dependency to your pom.xml:

[source,xml]
----
        <dependency>
            <groupId>ch.petikoch.libs</groupId>
            <artifactId>jtwfg</artifactId>
            <version>1.0.0</version> <!-- or whatever version -->
            <!-- or latest release (not snapshot), for the braves
            <version>RELEASE</version>
            -->
        </dependency>
----

Be sure to have Bintray's JCenter repository in your maven settings.xml. If not, see "Set me up!" on the
https://bintray.com/bintray/jcenter page for instructions to set it up.

==== Just the jar

The jar of each released version is located here image:http://img.shields.io/badge/download-latest-bb00bb.svg[link="https://bintray.com/{bintray-user}/maven/{project-name}/_latestVersion"]

== Release notes

See https://github.com/Petikoch/jtwfg/releases.

== Support

Please use GitHub issues and Pull Requests for support.

== How to build the project

If you cloned this git repository and would like to run a build on your machine, start the gradle based build using
gradle's http://gradleware.com/registered-access?content=screencasts%2Fthe-gradle-wrapper%2F[gradlewrapper]:

[source]
----
> ./gradlew build
----


